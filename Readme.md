# 微信富媒体传输系统

## 数据结构定义

### 消息包

```c++
struct Package {
    MSG_TYPE msg_type;
    FILE_TYPE file_type;
    char file_name[256];
    uint64_t file_size;
    uint32_t block_now_num;
    uint64_t off_set;
    Package(MSG_TYPE tp = MSG_TYPE_INIT_STATUS, FILE_TYPE ftp = FILE_TYPE_INIT_STATUS,
            char *fname = nullptr, uint64_t fsize = 0, uint32_t block = 0)
            : msg_type(tp), file_type(ftp), file_size(fsize), block_now_num(block) {
        // bzero((void *)file_name, sizeof(file_name));
        memset(file_name, 0, sizeof(file_name));
        if (fname) strcpy(file_name, fname);
    }
};

enum MSG_TYPE : int8_t {
    MSG_TYPE_INIT_STATUS = 0,

    DOWNLOAD_SEND_FILE_NAME,     //下载:阶段I -> 客户端向服务器发送 文件信息请求，         发送完毕后需等待 服务器返回文件信息
    DOWNLOAD_SEND_BLOCK_NUM,     //下载:阶段II -> 向服务器发送 要下载的大文件的BLOCK_NUM, 发送完毕后需要等待 服务器返回对应的文件内容, 如果需要断点续传，只需要客户端在包头中，设置好off_set即可
    DOWNLOAD_FILE_OVER,          //下载:阶段III -> 全部文件接收完毕，客户端需要发送给服务端一个信息

    UPLOAD_SEND_FILE_INFO,       //上传:阶段I -> 向服务器发送 文件信息， 客户端发送完毕后需等待服务端的回包
    UPLOAD_SEND_BLOCK_INFO,      //上传:阶段II -> 向服务器发送 块信息， 等回包后 再发主体， 再等回包确认接收完毕， 如果没有收到回包，或者中途断开，则发送断点续传请求
    UPLOAD_BREAKPOINT_QUERY,     //上传:断点查询：意外断开连接后，客户端询问服务端，某blockNo的偏移量，服务端会回复off_set(断点续传)
    UPLOAD_FILE_OVER,           //上传完毕，客户端发包给服务端，告知上传完毕

    MSG_TYPE_SIZE,               //用于记录一共有多少中msg_type

    OK,                  //回复:成功
    FAILED,              //回复:失败

};

enum FILE_TYPE : int8_t {
    FILE_TYPE_INIT_STATUS = 0,
    BIG_FILE,       //大文件
    SMALL_FILE,     //小文件
};
```

## 客户端

### 文件下载

小文件下载流程：
1. 根据需求，将包含文件名的文件信息请求包发送到服务端
2. 若文件信息请求包发送不出去则更换代理节点，若收不到回包则重新发送文件信息请求包，三次重新发送都没回包则更换代理节点
3. 解析读取回包内容，根据回包包含的文件大小判断执行小文件下载逻辑
4. 直接接收小文件包体，收不到回包则执行和第2步同样的策略，收到回包内容存入缓存中，判断接受包尺寸是否正确，不正确则重新请求
5. 包体尺寸正确，储存到磁盘，完成小文件下载流程

大文件下载流程：
1. 根据需求，将包含文件名的文件信息请求包发送到服务端
2. 若文件信息请求包发送不出去则更换代理节点，若收不到回包则重新发送文件信息包，三次重新发送都没回包则更换代理节点
3. 解析读取回包内容，根据回包包含的文件大小判断执行大文件下载逻辑
4. 启用多线程，每个线程独立申请文件切分成的不同块
5. 接收服务端回包，收不到回包则执行和第2步同样的策略，收到回包内容存入开辟的缓存中，判断接受包尺寸是否正确，不正确则重新请求
6. 包体尺寸正确，储存到磁盘，完成大文件下载流程

### 文件上传

小文件上传流程：
1. 根据需求，将包含文件名和文件尺寸的文件信息包发送到服务端
2. 若文件信息包发送不出去则更换代理节点，若收不到回包则重新发送文件信息请求包，三次重新发送都没回包则更换代理节点
3. 等待服务端的回包，解析读取回包内容，根据回包包含的内容是否为OK判断是否发送包体，回包信息不为OK，重发文件信息包
4. 回包信息为OK，直接发送小文件包体，并等待回包，解析读取回包内容，若回包信息不为OK，重新发包体，若为OK则结束小文件上传流程

大文件上传流程：
1. 根据需求，将包含文件名和文件尺寸的文件信息包发送到服务端
2. 若文件信息包发送不出去则更换代理节点，若收不到回包则重新发送文件信息请求包，三次重新发送都没回包则更换代理节点
3. 等待服务端的回包，解析读取回包内容，根据回包包含的信息是否为OK判断是否启动大文件上传流程，若不为OK，重发文件信息包
4. 若回包包含的信息为OK，启用多线程，将大文件分块，每个线程独立执行不同块的内容发送
5. 在每个线程中发送文件分块包头信息，包含上传包类型，实际发送包体尺寸，总文件大小，文件名等，等待服务端的回包，若回包包含消息不为OK，重发文件分块包头信息
6. 在各个线程中收到服务端的回包包含消息为OK，发送大文件包体，并等待回包，解析读取回包内容，若回包信息不为OK，重新发包体，若为OK则结束大文件上传流程

### 容灾设计

- 客户端连接的proxy如果被kill，更换proxy节点，重新向客户端的proxy发起连接请求，重新开始一次新的流程

## 代理端

### **数据转发流程**

#### 主线程流程

1.Listen fd注册进epoll

2.对epoll返回值进行判断，listen_fd执行Accept和connect建立前端和后端连接，同时将对应的fd注册进epoll

3.epoll返回用于连接的文件描述符，执行收发操作

![img](https://img2020.cnblogs.com/blog/1756893/202008/1756893-20200824114915283-1347053427.png)

为了提升系统的并发能力，将socket收发编程任务队列及工作线程模型，收到用于连接的文件描述符，执行进队操作

![img](https://img2020.cnblogs.com/blog/1756893/202008/1756893-20200824114924198-1003414745.png)

#### 工作线程流程

1.队列非空且收到信号，从任务队列中取fd

2.执行循环收发逻辑，直到出现EAGAIN，接收缓冲区内容为空，重新注册fd

![img](https://img2020.cnblogs.com/blog/1756893/202008/1756893-20200824114929184-1007043861.png)

#### 设计关键点

1.执行listen的socket设置SO_REUSEADDR

2.转发fd的绑定利用hashmap进行映射

3.accept以及connect函数处理的socket设置非阻塞模式，妥善处理EAGAIN问题

4.搭配使用Epoll的触发模式采用EPOLLET和ONESHOT，并重新进行EPOLL_CTL

5.send函数设置MSG_NOSINGAL,避免SIGPIPE信号导致的程序异常退出



#### 容灾设计

proxy会在程序运行的过程中被挂掉。

对于client-proxy来说，如果server-proxy被kill掉，client-proxy断开与server-proxy的连接，同时关闭对应session对端fd，使得client，感知proxykill，重新申请未获取的文件块，client-proxy执行connect过程中，实行主备思想，如果一个proxy无法连接，则转到另一个proxy进行连接。

对于server-proxy来说，如果client-proxy被kill掉，关闭session连接两端fd，等待重连即可



## 服务端

### 文件下载

小文件下载流程：

1. 接收到客户端发送的文件信息请求包，读取包中的文件名
2. 根据文件名读取本地文件，判断文件大小
3. 判断为小文件，直接发送小文件给客户端
4. 接收到客户端的下载完成包，完成下载流程

大文件下载流程：

1. 接收到客户端发送的文件信息请求包，读取包中的文件名
2. 根据文件名读取本地文件，判断文件大小
3. 判断为大文件，将文件的大小发给客户端
4. 客户端根据文件大小将文件分块，然后发送块信息到服务端
5. 根据块的信息，读取相应的内容，返回给客户端

![img](https://img2020.cnblogs.com/blog/1756893/202008/1756893-20200821214459096-1911625725.png)

![img](https://img2020.cnblogs.com/blog/1756893/202008/1756893-20200821214626734-1166970986.png)

### 文件上传

小文件上传流程：

1. 接收到客户端发送的文件信息，解析包中的文件信息，创建对应大小的文件
2. 判断文件的大小
3. 判断为小文件，回复OK包，准备接收文件
4. 接收文件完成，回复OK包

大文件上传流程：

1. 接收到客户端发送的文件信息，解析包中的文件信息，创建对应大小的文件
2. 判断文件的大小
3. 判断为大文件，回复OK包
4. 客户端发送块信息，服务端解析包内容，回复OK包，准备接收文件块
5. 文件块接收完毕，回复OK包
6. 所有文件块上传完毕，流程结束

![img](https://img2020.cnblogs.com/blog/1756893/202008/1756893-20200821214447484-564149789.png)

![img](https://img2020.cnblogs.com/blog/1756893/202008/1756893-20200821214402801-354779870.png)

### 多线程

- 主线程通过epoll监听前端proxy的所有fd
- 如果是tcp连接请求，则接受连接，并将连接加入epoll
- 如果是对应fd收到数据，将对应fd加入处理队列
- 多个线程从处理队列取出相应的fd，根据收到MSG_TYPE，调用相应的函数进行处理

![img](https://img2020.cnblogs.com/blog/1756893/202008/1756893-20200821220605980-1418623454.png)

### 容灾设计

- 服务端连接的proxy如果被kill，则服务端关闭和此proxy的所有连接，等待客户端的重新连接

